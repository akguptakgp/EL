from sets import Set
import en

# read the parse file generated by standford parser
f = open('output_task3_PARSE.txt', 'r')
if(f!=None):
    str1=f.read().splitlines()
    arr=""
    for line in str1:
        arr+=line.lower()
    ar=arr.replace('','')
else:
    print "error opening the file"

# parse the file to populate trees
DEP_TREE=[]
itr=0
is_qst=False
if(ar.find("(. .)))")!=-1): 
    while(ar.find("(. .)))")!=-1):
        itr+=1
        if(itr!=1):
            tmp=num1
        num1=ar.find("(ROOT  (")
        if(itr!=1):
            DEP_TREE.append(ar[(ar[:num1].find(". .)))")+6):num1])
        num2=ar.find("(. .)))")
        temp1=ar[num1:num2]
        ar=ar[num2+1:len(ar)]
    DEP_TREE.append(ar[(ar[:num1].find(". .)))")+6):])
elif(ar.find("(. ?)))")!=-1):
    is_qst=True
    while(ar.find("(. ?)))")!=-1):
        itr+=1
        if(itr!=1):
            tmp=num1
        num1=ar.find("(ROOT  (")
        if(itr!=1):
            DEP_TREE.append(ar[(ar[:num1].find(". ?)))")+6):num1])
        num2=ar.find("(. ?)))")
        temp1=ar[num1:num2]
        ar=ar[num2+1:len(ar)]
    DEP_TREE.append(ar[(ar[:num1].find(". ?)))")+6):])
else:
    while(ar.rfind(")))")!=-1):
        itr+=1
        if(itr!=1):
            tmp=num1
        num1=ar.find("(ROOT  (")
        if(itr!=1):
            DEP_TREE.append(ar[(ar[:num1].find(")))")+6):num1])
        num2=ar.find(")))")
        temp1=ar[num1:num2]
        ar=ar[num2+1:len(ar)]
    DEP_TREE.append(ar[(ar[:num1].find(")))")+6):])

# English Grammer stuffs
# subject object conversion Rule, person rule 
tmp={'i':'me','you':'you','we':'us','they':'them','it':'it','he':'him','she':'her'}
Subj_Obj={'i':'me','you':'you','we':'us','they':'them','it':'it','he':'him','she':'her'}
number_person_table={
'i' : (1,2),
'you' : (2,2),
'he': (3,1),
'she': (3,1),
'it' : (3,1),
'we' : (1,2) ,
'they' : (3,2)
}
for k,v in tmp.items():
    Subj_Obj[v]=k

# English grammer stuff finish

NewDeps=[]
HV=''
oldSub=''
oldObj=''
newSubj=''
newObj=''
neg=None
Oldverb=''

# change the dependecy according to Passive to Active Ruls
for i in DEP_TREE[0].split(')'):
    if(i!=''):
        p=i.split('(')
        relation=p[0]
        first=p[1].split(',')[0]
        second=p[1].split(',')[1]
        first=first.lower().strip()
        second=second.lower().strip()
        if('case' in relation):
            pass
        elif('nmod' in relation):
            NewDeps.append(('nsubj',first,second))
            second_split=second.split('-')
            oldObj=second_split[0]
            if second_split[0] in Subj_Obj:
                newSubj=Subj_Obj[second_split[0]]
            else:
                newSubj=second_split[0]
        elif('nsubj' in relation):
            NewDeps.append(('dobj',first,second))

            second_split=second.split('-')
            Oldverb=first.split('-')[0]
            oldSub=second_split[0]
            if second_split[0] in Subj_Obj:
                newObj=Subj_Obj[second_split[0]]
            else:
                newObj=second_split[0]
        elif('aux' in relation or 'cop' in relation):
            HV+=' '+second.split('-')[0]
        elif('neg' in relation):
            neg=  (relation,first,second)  
        else:
            NewDeps.append((relation,first,second))
  
newSubjPrefix=''
newObjPrefix=''

for i in NewDeps:
    if oldObj == i[1].split('-')[0]:
        newSubjPrefix+=' '+i[2].split('-')[0]
    if oldSub == i[1].split('-')[0]:
        newObjPrefix+=' '+i[2].split('-')[0]    

def changeVerb(hp,neg,sub,verb):
    hp=hp.lower()
    sub=sub.lower()
    verb=verb.lower()
    
    person=None
    if sub in number_person_table:
        person=number_person_table[newSubj]
    else:
        person=(3,1)
    # print "called",hp,sub,verb    
    # print "person=",person[0]    

    if(hp in ['am','is','are']):
        if(neg==None and not is_qst):
            try:
                return ('',en.verb.present(verb, person=person[0], negate=False))
            except:
                return('',verb)    
        else:
            if(not is_qst):
                tmp=['does not','do not']
            else:
                tmp=['does','do']   
            try:
                return (tmp[person[1]-1],en.verb.present(verb))
            except:
                return(tmp[person[1]-1],verb)
    elif(hp in ['am being','is being','are being']):
        if('i'==sub):
            tmp='am'
        else:
            tmp=['is','are'][person[1]-1]
            
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.present_participle(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.present_participle(verb))
            except:
                return(tmp+' not',verb)
    elif(hp in ['has been','have been']):
        tmp=['has','have'][person[1]-1]
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.past(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.past(verb))
            except:
                return(tmp+' not',verb)
    elif(hp in ['was','were']):
        if(neg==None and not is_qst):
            try:
                return ('',en.verb.past(verb))
            except:
                return('',verb)    
        else:
            if(not is_qst):
                tmp='did not'
            else:
                tmp='did'
            try:
                return (tmp,en.verb.present(verb))
            except:
                return(tmp,verb)
    elif(hp in ['was being','were being']):
        tmp=['was','were'][person[1]-1]
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.present_participle(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.present_participle(verb))
            except:
                return(tmp+' not',verb)
    elif(hp in ['had been']):
        tmp='had'
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.past(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.past(verb))
            except:
                return(tmp+' not',verb)
    elif(hp in ['will be','would be','shall be']):
        tmp=hp.split()[0]
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.present(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.present(verb))
            except:
                return(tmp+' not',verb)
    elif(hp in ['will have been','would have been','shall have been']):
        tmp=hp.split()[0]+' '+hp.split()[1]
        if(neg==None or is_qst):
            try:
                return (tmp,en.verb.past(verb))
            except:
                return(tmp,verb)    
        else:
            try:
                return (tmp+' not',en.verb.past(verb))
            except:
                return(tmp+' not',verb)                                                

newHV=changeVerb(HV[1:],neg,newSubj,Oldverb)

# print "neHV",newHV
if(len(newObjPrefix)>=1):
    newObj=newObjPrefix[1:]+' '+newObj

if(len(newSubjPrefix)>=1):
    newSubj=newSubjPrefix[1:]+' '+newSubj 

# print newSubj
# print newObj
# print is_qst
print
print "Active Voice Representation of input sentence is"
if(is_qst):
    if(len(newHV[0].split())<=1):
        print newHV[0]+' '+newSubj+' '+newHV[1]+' '+newObj+' ?'
    else:
        t=''
        for i in range(1,len(newHV[0].split())):
            t+=newHV[0].split()[i]+' '
        print newHV[0].split()[0]+' '+newSubj+' '+t+newHV[1]+' '+newObj+' ?'    
else:
    print newSubj+' '+newHV[0]+' '+newHV[1]+' '+newObj+' .'    
print

